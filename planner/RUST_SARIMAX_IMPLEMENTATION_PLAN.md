# RUST_SARIMAX_IMPLEMENTATION_PLAN.md

## SARIMAX 모델 Rust 코어 전환 및 pyo3 바인딩 설계 계획서

------------------------------------------------------------------------

# 1. 프로젝트 목적

본 문서는 Python `statsmodels.SARIMAX` 기반 시계열 통계 모델의 핵심
계산부를 Rust로 이전하기 위한 구체적인 기술 계획을 정의한다.

목표는 다음과 같다:

-   대규모 배치 시계열 처리 속도 향상
-   Python GIL 제약 해소
-   멀티스레드 병렬 처리 기반 확장성 확보
-   기존 Python 파이프라인 변경 최소화
-   statsmodels와 수치적으로 동일한 결과 보장

------------------------------------------------------------------------

# 2. 전체 아키텍처 전략

## 설계 철학

> Python = Orchestration Layer\
> Rust = Numerical Engine

------------------------------------------------------------------------

## 아키텍처 구조

    Python Layer
     ├─ 데이터 전처리
     ├─ 모델 스펙 정의
     ├─ scipy.optimize (fit)
     ├─ AIC/BIC 계산
     └─ 결과 리포팅

            ↓ (pyo3 binding)

    Rust Layer
     ├─ Parameter unpacking
     ├─ State Space construction
     ├─ Kalman Filter
     ├─ Log-likelihood 계산
     ├─ Forecast 계산
     └─ (선택) Gradient 계산

------------------------------------------------------------------------

# 3. 단계별 개발 계획

------------------------------------------------------------------------

# Phase 1 --- 최소 PoC 구현

## 목표

-   Rust에서 SARIMAX log-likelihood 계산 구현
-   Python에서 pyo3 바인딩 호출 가능
-   statsmodels와 loglike 비교 가능 상태 확보

------------------------------------------------------------------------

## 3.1 지원 범위 (초기 버전)

지원:

-   SARIMAX(p,d,q)
-   Seasonal(P,D,Q,s)
-   exogenous regressors
-   trend="n"
-   enforce_stationarity=False
-   enforce_invertibility=False

제외:

-   measurement_error
-   time-varying parameters
-   complex diffuse 초기화 옵션

------------------------------------------------------------------------

## 3.2 프로젝트 구조

    sarimax_rs/
     ├── Cargo.toml
     ├── pyproject.toml
     ├── src/
     │    ├── lib.rs
     │    ├── params.rs
     │    ├── state_space.rs
     │    ├── kalman.rs
     │    └── likelihood.rs
     └── python_tests/
          ├── test_loglike.py
          └── test_vs_statsmodels.py

------------------------------------------------------------------------

## 3.3 핵심 모듈 설명

### params.rs

-   statsmodels param 벡터 언팩
-   AR, MA, Seasonal 계수 분리
-   exog 계수 분리
-   sigma² 추출

------------------------------------------------------------------------

### state_space.rs

-   ARIMA → 상태공간 변환
-   상태 전이 행렬 F 구성
-   관측 행렬 H 구성
-   공분산 행렬 Q, R 구성

------------------------------------------------------------------------

### kalman.rs

-   Kalman Filter 구현
-   예측 단계
-   업데이트 단계
-   예측 오차 계산
-   수치 안정성 확보 (Cholesky 기반)

------------------------------------------------------------------------

### likelihood.rs

-   log-likelihood 계산
-   수치 안정성 보장
-   underflow 방지

------------------------------------------------------------------------

### lib.rs

-   pyo3 바인딩
-   numpy 배열 → Rust slice zero-copy
-   Python 호출 API 제공

------------------------------------------------------------------------

# 4. Python 바인딩 API 설계

## 최소 API

``` python
ll = sarimax_rs.sarimax_loglike(
    y,
    exog,
    order=(p,d,q),
    seasonal=(P,D,Q,s),
    params=params
)
```

------------------------------------------------------------------------

## 추후 확장 API

``` python
mean, var = sarimax_rs.sarimax_forecast(
    y,
    exog,
    order,
    seasonal,
    params,
    steps,
    exog_future
)
```

------------------------------------------------------------------------

# 5. Phase 2 --- statsmodels 완전 동일성 확보

## 목표

-   loglike 차이 \< 1e-6
-   동일 params 입력 시 동일 결과

------------------------------------------------------------------------

## 작업 목록

-   statsmodels 파라미터 레이아웃 정확히 복제
-   초기화 방식 일치
-   sigma² 처리 방식 동일화
-   enforce_stationarity 변환 구현 여부 결정
-   residual 계산 동일화

------------------------------------------------------------------------

## 검증 항목

-   log-likelihood
-   one-step-ahead residual
-   forecast mean
-   forecast variance

------------------------------------------------------------------------

# 6. Phase 3 --- Fit 가속 전략

## 옵션 A (권장)

Python에서 최적화 수행

    scipy.optimize.minimize(
        lambda params: -sarimax_rs.loglike(...)
    )

Rust는 loglike/gradient만 제공

------------------------------------------------------------------------

## 옵션 B

Rust 내부 L-BFGS 구현

→ 완전 Rust fit 가능

------------------------------------------------------------------------

# 7. Phase 4 --- 배치 병렬화

## 목표

-   N개 시계열 병렬 처리
-   Rayon 기반 멀티스레드

API 예시:

``` python
ll_list = sarimax_rs.batch_loglike(
    y_list,
    exog_list,
    ...
)
```

------------------------------------------------------------------------

# 8. 성능 기대 효과

  시나리오           기대 개선
  ------------------ -----------
  단일 시계열        1.3배
  1000개 배치        3\~8배
  Rolling forecast   5배 이상

------------------------------------------------------------------------

# 9. 리스크 분석

## 기술 리스크

1.  statsmodels 내부 구현과 완전 동일성 확보
2.  수치 안정성 문제
3.  초기 상태 설정 차이

------------------------------------------------------------------------

## 대응 전략

-   작은 모델부터 단계적 검증
-   단위 테스트 자동화
-   허용 오차 명확화
-   점진적 기능 확장

------------------------------------------------------------------------

# 10. 일정 계획

  단계      예상 기간
  --------- -----------
  Phase 1   2\~3주
  Phase 2   2\~4주
  Phase 3   1\~2주
  Phase 4   1\~2주

총 예상 기간: 6\~10주

------------------------------------------------------------------------

# 11. 성공 기준

-   statsmodels 대비 loglike 차이 \< 1e-6
-   1000개 배치 처리 시 3배 이상 성능 개선
-   기존 Python 코드 수정 최소화

------------------------------------------------------------------------

# 12. 장기 확장 비전

-   WASM 빌드 → 브라우저 예측
-   gRPC 기반 모델 서버화
-   Rust 단독 CLI 실행기
-   Arrow/Polars 직접 연동
-   완전 Rust 기반 시계열 엔진으로 확장

------------------------------------------------------------------------

# 최종 결론

가장 현실적이며 안정적인 접근은 다음 순서이다:

1)  Log-likelihood Rust화\
2)  statsmodels와 수치 동일성 확보\
3)  Batch 병렬화\
4)  Forecast 및 Fit 확장

이 전략은 리스크를 최소화하면서 성능 개선을 극대화할 수 있는 구조이다.
